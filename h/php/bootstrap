#!/opt/bin/php -c/opt/php.ini
<?php
echo 'Cold start' . PHP_EOL;

ini_set('display_errors', '1');
error_reporting(E_ALL);

$lambdaRuntimeApi = getenv('AWS_LAMBDA_RUNTIME_API');

require __DIR__ . '/vendor/autoload.php';

while (true) {
    // This is a blocking HTTP call until an event is available
    [$event, $invocationId] = waitForEventFromLambdaApi($lambdaRuntimeApi);

    // Sets some sane defaults here so that this function doesn't fail
    // when it's not handling a HTTP request from API Gateway.
    $requestMethod = array_key_exists('httpMethod', $event ) ? $event['httpMethod'] : 'GET';
    $requestBody = array_key_exists('body', $event ) ? $event['body'] : '';
    $serverName = array_key_exists('headers', $event ) ? $event['headers']['Host'] : 'lambda_test.dev';
    $requestUri = array_key_exists('path', $event ) ? $event['path'] : '';
    $headers = [];
    $queryParams = '';

    // Convert all headers passed by API Gateway into the correct format for PHP CGI.
    // This means converting a header such as "X-Test" into "HTTP_X-TEST".
    if (array_key_exists('headers', $event )) {
        foreach ($event['headers'] as $key => $value) {
            $header = strtoupper(str_replace('-', '_', $key));
            $headers[$header] = $value;
            $headers['HTTP_' . $header] = $value;

        }
    }

    // Convert query parameters passed by API Gateway into the correct format for PHP CGI.
    if (array_key_exists('queryStringParameters', $event ) && !empty($event['queryStringParameters'])) {
        $parameters = [];

        foreach ($event['queryStringParameters'] as $key => $value) {
            $parameters[] = $key . '=' . $value;
        }
        $queryParams = join("&", $parameters);
    }

    // Spawn the PHP CGI process with a bunch of environment variables that describe the request.
    $scriptPath = __DIR__ . '/index.php';

    $descriptorspec = array(
        0 => array("pipe", "r"),  // stdin is a pipe that the child will read from
        1 => array("pipe", "w"),  // stdout is a pipe that the child will write to
        2 => array("pipe", "w") // stderr is a file to write to
    );

    $env = [
        'REDIRECT_STATUS' => 200,
        'REQUEST_METHOD' => $requestMethod,
        'SCRIPT_FILENAME' => $scriptPath,
        'SCRIPT_NAME' => '/index.php',
        'PATH_INFO' => '/',
        'SERVER_NAME' => $serverName,
        'SERVER_PROTOCOL' => 'HTTP/1.1',
        'REQUEST_URI' => $requestUri,
        'QUERY_STRING' => $queryParams,
        'AWS_LAMBDA' => true,
        'CONTENT_LENGTH' => mb_strlen($requestBody, 'UTF-8')
    ];

    $env = array_merge($_ENV, $env, $headers);
    $cwd = '/var/task';

    $process = proc_open("/opt/bin/php -c/opt/php.ini -f$scriptPath", $descriptorspec, $pipes, $cwd, $env);

    if (is_resource($process)) {
        // $pipes now looks like this:
        // 0 => writeable handle connected to child stdin
        // 1 => readable handle connected to child stdout
        // Any error output will be appended to /tmp/error-output.txt

        fwrite($pipes[0], $requestBody);
        fclose($pipes[0]);

        $lambdaResponse = stream_get_contents($pipes[1]);
        fclose($pipes[1]);

        $error = stream_get_contents($pipes[2]);
        fclose($pipes[2]);

        // It is important that you close any pipes before calling
        // proc_close in order to avoid a deadlock
        $return_value = proc_close($process);
        if ($return_value === 0){
            print("SUCCEEDED\n");
            signalSuccessToLambdaApi($lambdaRuntimeApi, $invocationId, $lambdaResponse);
        }else{
            print("FAILED: $error\n");
            print_r(scandir('/opt/bin'));
            fail($lambdaRuntimeApi, $invocationId, $lambdaResponse);
        }
    }else{
        fail($lambdaRuntimeApi, $invocationId, 'Failed to run php-cgi');
    }
}

function waitForEventFromLambdaApi(string $lambdaRuntimeApi): ?array
{
    $ch = curl_init("http://$lambdaRuntimeApi/2018-06-01/runtime/invocation/next");

    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);
    curl_setopt($ch, CURLOPT_FAILONERROR, true);

    $invocationId = '';

    curl_setopt($ch, CURLOPT_HEADERFUNCTION, function ($ch, $header) use (&$invocationId) {
        if (! preg_match('/:\s*/', $header)) {
            return strlen($header);
        }

        [$name, $value] = preg_split('/:\s*/', $header, 2);

        if (strtolower($name) == 'lambda-runtime-aws-request-id') {
            $invocationId = trim($value);
        }

        return strlen($header);
    });

    $body = '';

    curl_setopt($ch, CURLOPT_WRITEFUNCTION, function ($ch, $chunk) use (&$body) {
        $body .= $chunk;

        return strlen($chunk);
    });

    curl_exec($ch);

    if (curl_error($ch)) {
        die('Failed to fetch next Lambda invocation: ' . curl_error($ch) . "\n");
    }

    if ($invocationId == '') {
        die('Failed to determine Lambda invocation ID');
    }

    curl_close($ch);

    if (! $body) {
        die("Empty Lambda invocation response\n");
    }

    $event = json_decode($body, true);

    if (! array_key_exists('requestContext', $event)) {
        fail($lambdaRuntimeApi, $invocationId, 'Event is not an API Gateway request');
        return null;
    }

    return [$event, $invocationId];
}

function signalSuccessToLambdaApi(string $lambdaRuntimeApi, string $invocationId, LambdaResponse $response)
{
    $ch = curl_init("http://$lambdaRuntimeApi/2018-06-01/runtime/invocation/$invocationId/response");

    $response_json = $response->toJson();

    curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'POST');
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
    curl_setopt($ch, CURLOPT_POSTFIELDS, $response_json);
    curl_setopt($ch, CURLOPT_HTTPHEADER, [
        'Content-Type: application/json',
        'Content-Length: ' . strlen($response_json),
    ]);

    curl_exec($ch);
    curl_close($ch);
}

function fail($lambdaRuntimeApi, $invocationId, $errorMessage)
{
    $ch = curl_init("http://$lambdaRuntimeApi/2018-06-01/runtime/invocation/$invocationId/response");

    $response = [];

    $response['statusCode'] = 500;
    $response['body'] = $errorMessage;

    $response_json = json_encode($response);

    curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'POST');
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
    curl_setopt($ch, CURLOPT_POSTFIELDS, $response_json);
    curl_setopt($ch, CURLOPT_HTTPHEADER, [
        'Content-Type: application/json',
        'Content-Length: ' . strlen($response_json),
    ]);

    curl_exec($ch);
    curl_close($ch);
}
