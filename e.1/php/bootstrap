#!/opt/bin/php -c/opt/php.ini
<?php

echo 'Cold start' . PHP_EOL;

ini_set('display_errors', '1');
error_reporting(E_ALL);

$lambdaRuntimeApi = getenv('AWS_LAMBDA_RUNTIME_API');

require __DIR__ . '/vendor/autoload.php';

use Bref\Bridge\Psr7\RequestFactory;
use Bref\Http\LambdaResponse;
use Psr\Http\Message\RequestInterface;
use hollodotme\FastCGI\Client;
use hollodotme\FastCGI\SocketConnections\UnixDomainSocket;
use Symfony\Component\Process\Process;

class PsrRequest extends \hollodotme\FastCGI\Requests\AbstractRequest {
    /** @var  RequestInterface */
    protected $request;
    public function __construct(string $scriptFilename, RequestInterface $request)
    {
        $this->request = $request;
        parent::__construct($scriptFilename, (string) $request->getBody());
        $this->setRequestUri((string) $request->getUri());
    }
    public function getRequestMethod(): string
    {
        return $this->request->getMethod();
    }

    public function getScriptFilename(): string
    {
        return __DIR__ . '/index.php';
    }
}

$cgi = new Process("php-cgi -b /tmp/php-cgi.sock -c /opt/php.ini -d extension_dir=/opt/php/extensions");
$cgi->setTimeout(null);
$cgi->start(function ($type, $output) {
    print("DUMP\n");
    var_dump($output);
    if ($type === Process::ERR) {
        echo($output);
        exit(1);
    }
});

register_shutdown_function(function() use(&$cgi) {
    $cgi->stop();
});

// Wait for the server to start
usleep(1000000);

$connection = new UnixDomainSocket('/tmp/php-cgi.sock');
$client = new Client( $connection );

while (true) {
    // This is a blocking HTTP call until an event is available
    [$event, $invocationId] = waitForEventFromLambdaApi($lambdaRuntimeApi);
    processEvent($client, $event, $lambdaRuntimeApi, $invocationId);
}


/**
 * @param Client $client
 * @param $event
 * @param $lambdaRuntimeApi
 * @param $invocationId
 * @throws Throwable
 * @throws \hollodotme\FastCGI\Exceptions\ConnectException
 * @throws \hollodotme\FastCGI\Exceptions\TimedoutException
 * @throws \hollodotme\FastCGI\Exceptions\WriteFailedException
 */
function processEvent(Client $client, $event, $lambdaRuntimeApi, $invocationId): void
{
    $scriptPath = __DIR__ . '/index.php';

    $request = RequestFactory::fromLambdaEvent($event);
    $fcgiRequest = new PsrRequest(getenv('_HANDLER'), $request);
    $fcgiRequest->setContent(array_key_exists('body', $event) ? (string)$event['body'] : '');
    $fcgiRequest->setContentType('application/json');
    $fcgiRequest->setServerName(array_key_exists('headers', $event) ? $event['headers']['Host'] : 'lambda_test.dev');
    print('SCRIPT: ' .$fcgiRequest->getScriptFilename() . "\n");
    $fcgiResponse = $client->sendRequest($fcgiRequest);
    print_r("RESPONSE: " . $fcgiResponse->getRawResponse() . "\n");
    print_r("RESPONSE: " . $fcgiResponse->getBody() . "\n");
    print_r($fcgiResponse->getHeaders());

    $lambdaResponse = new LambdaResponse(200, $fcgiResponse->getHeaders(), $fcgiResponse->getBody());
    signalSuccessToLambdaApi($lambdaRuntimeApi, $invocationId, $lambdaResponse);
}

function waitForEventFromLambdaApi(string $lambdaRuntimeApi): ?array
{
    $ch = curl_init("http://$lambdaRuntimeApi/2018-06-01/runtime/invocation/next");

    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);
    curl_setopt($ch, CURLOPT_FAILONERROR, true);

    $invocationId = '';

    curl_setopt($ch, CURLOPT_HEADERFUNCTION, function ($ch, $header) use (&$invocationId) {
        if (! preg_match('/:\s*/', $header)) {
            return strlen($header);
        }

        [$name, $value] = preg_split('/:\s*/', $header, 2);

        if (strtolower($name) == 'lambda-runtime-aws-request-id') {
            $invocationId = trim($value);
        }

        return strlen($header);
    });

    $body = '';

    curl_setopt($ch, CURLOPT_WRITEFUNCTION, function ($ch, $chunk) use (&$body) {
        $body .= $chunk;

        return strlen($chunk);
    });

    curl_exec($ch);

    if (curl_error($ch)) {
        die('Failed to fetch next Lambda invocation: ' . curl_error($ch) . "\n");
    }

    if ($invocationId == '') {
        die('Failed to determine Lambda invocation ID');
    }

    curl_close($ch);

    if (! $body) {
        die("Empty Lambda invocation response\n");
    }

    $event = json_decode($body, true);

    if (! array_key_exists('requestContext', $event)) {
        fail($lambdaRuntimeApi, $invocationId, 'Event is not an API Gateway request');
        return null;
    }

    return [$event, $invocationId];
}

function signalSuccessToLambdaApi(string $lambdaRuntimeApi, string $invocationId, LambdaResponse $response)
{
    $ch = curl_init("http://$lambdaRuntimeApi/2018-06-01/runtime/invocation/$invocationId/response");

    curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'POST');
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
    curl_setopt($ch, CURLOPT_POSTFIELDS, $response->toJson());
    curl_setopt($ch, CURLOPT_HTTPHEADER, [
        'Content-Type: application/json',
        'Content-Length: ' . strlen($response->toJson()),
    ]);

    curl_exec($ch);
    curl_close($ch);
}

function fail($lambdaRuntimeApi, $invocationId, $errorMessage)
{
    $ch = curl_init("http://$lambdaRuntimeApi/2018-06-01/runtime/invocation/$invocationId/response");

    $response = [];

    $response['statusCode'] = 500;
    $response['body'] = $errorMessage;

    $response_json = json_encode($response);

    curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'POST');
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
    curl_setopt($ch, CURLOPT_POSTFIELDS, $response_json);
    curl_setopt($ch, CURLOPT_HTTPHEADER, [
        'Content-Type: application/json',
        'Content-Length: ' . strlen($response_json),
    ]);

    curl_exec($ch);
    curl_close($ch);
}
